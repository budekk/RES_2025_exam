# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ez6uZWDGXVKSiA3P6eqzTZ0_i1PL5mzY
"""

!pip install rasterio
print("Rasterio imported successfully!")
from sklearn.cluster import KMeans
import pandas as pd
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
import matplotlib.pyplot as plt
import numpy as np
import rasterio
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.metrics import cohen_kappa_score
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, accuracy_score, cohen_kappa_score, classification_report
import numpy as np
import rasterio
import matplotlib.pyplot as plt

def load_raster(file_path):
    try:
        with rasterio.open(file_path) as src:
            return src.read(1), src.profile
    except Exception as e:
        print(f"Error loading raster {file_path}: {e}")
        return None, None

def accuracy_assessment(raster_path, reference_path):
    raster, _ = load_raster(raster_path)
    reference, _ = load_raster(reference_path)

    if raster is None or reference is None:
        print("Error: One or both rasters could not be loaded.")
        return None, None, None

    # Flatten arrays and remove nodata values (assuming 0 as nodata, modify if needed)
    mask = (reference > 0) & (raster > 0)

    if not np.any(mask):
        print("Error: No valid data found after applying mask.")
        return None, None, None

    raster_values = raster[mask].flatten()
    reference_values = reference[mask].flatten()

    # Compute confusion matrix and metrics
    conf_matrix = confusion_matrix(reference_values, raster_values)
    overall_acc = accuracy_score(reference_values, raster_values)
    kappa = cohen_kappa_score(reference_values, raster_values)

    return conf_matrix, overall_acc, kappa

def classify_kmeans(raster, n_clusters=5):
    masked_values = raster[raster > 0].reshape(-1, 1)  # Przygotowanie danych
    kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
    classified = np.zeros_like(raster)
    classified[raster > 0] = kmeans.fit_predict(masked_values) + 1  # Klasy od 1
    return classified

def classify_random_forest(raster, reference):
    mask = (reference > 0) & (raster > 0)
    X_train = raster[mask].reshape(-1, 1)
    y_train = reference[mask].flatten()
    rf = RandomForestClassifier(n_estimators=100, random_state=42)
    rf.fit(X_train, y_train)
    classified = np.zeros_like(raster)
    classified[raster > 0] = rf.predict(raster[raster > 0].reshape(-1, 1))
    return classified

# Ścieżki do plików
raster_path = "/content/raster.tif"
reference_path = "/content/reference_raster.tif"

# Analiza dokładności
conf_matrix, overall_acc, kappa = accuracy_assessment(raster_path, reference_path)
if conf_matrix is not None:
    print("Confusion Matrix:\n", conf_matrix)
    print("Overall Accuracy:", overall_acc)
    print("Kappa Coefficient:", kappa)

    # Wczytanie rastra do klasyfikacji
    raster, _ = load_raster(raster_path)

    # Klasyfikacja metodą K-Means
    classified_kmeans = classify_kmeans(raster)

    # Klasyfikacja metodą Random Forest
    reference, _ = load_raster(reference_path)
    classified_rf = classify_random_forest(raster, reference)

# Wizualizacja wyników z nowymi kolorami
fig, axs = plt.subplots(1, 3, figsize=(15, 5))
axs[0].imshow(raster, cmap='gray')  # Original raster in grayscale
axs[0].set_title('Oryginalny raster')
axs[1].imshow(classified_kmeans, cmap='viridis')  # K-Means classification with 'viridis'
axs[1].set_title('Klasyfikacja K-Means')
axs[2].imshow(classified_rf, cmap='plasma')  # Random Forest classification with 'plasma'
axs[2].set_title('Klasyfikacja Random Forest')
plt.show()











