# -*- coding: utf-8 -*-
"""raster.tof_task3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fAaqXmkoqtK1bsxl1-Lj7DfFnINeFvBf
"""

!pip install rasterio
import rasterio
print("Rasterio imported successfully!")
from sklearn.cluster import KMeans
import numpy as np
import pandas as pd
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
import matplotlib.pyplot as plt

# Wczytaj raster
raster_path = "/content/raster.tif"
with rasterio.open(raster_path) as src:
    raster_data = src.read(1)  # Zakładamy, że raster ma tylko jedną warstwę
    profile = src.profile

# Sprawdź wartości unikalne (przydatne dla klasyfikacji)
unique_values = np.unique(raster_data)
print("Unikalne wartości w rastrze:", unique_values)

ground_truth_data = np.random.choice(unique_values, raster_data.shape)  # Symulacja referencji

# Spłaszczanie danych (potrzebne do analizy klasyfikacji)
flattened_raster = raster_data.flatten()
flattened_truth = ground_truth_data.flatten()

# Usunięcie wartości NoData (jeśli istnieją, np. -9999)
mask = (flattened_truth >= 0)  # Dostosuj w zależności od NoData w Twoim rastrze
flattened_raster = flattened_raster[mask]
flattened_truth = flattened_truth[mask]

# Obliczenie macierzy błędów
conf_matrix = confusion_matrix(flattened_truth, flattened_raster)
print("Macierz błędów:\n", conf_matrix)

# Obliczenie dokładności
overall_acc = accuracy_score(flattened_truth, flattened_raster)
print("Ogólna dokładność:", overall_acc)

# Szczegółowy raport klasyfikacji
report = classification_report(flattened_truth, flattened_raster, zero_division=0)
print("Raport klasyfikacji:\n", report)

# Wizualizacja macierzy błędów z innym kolorem
plt.figure(figsize=(8, 6))
plt.imshow(conf_matrix, cmap="viridis", interpolation="nearest")  # Zmieniony kolor
plt.colorbar(label="Liczba pikseli")
plt.xlabel("Przewidywane klasy")
plt.ylabel("Referencyjne klasy")
plt.title("Macierz błędów")
plt.show()